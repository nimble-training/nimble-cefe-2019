---
title: "Multi-State Capture-Recapture Model: Orchids"
output: html_document
---

---


```{r, echo = FALSE, message = FALSE}
library(nimble, quiet = TRUE)
load('~/github/nimble/nimble-cefe-2019/docs/data/orchid_data.Rdata')
```


\   

### Multi-State Capture-Recapture Model: Orchids


- From Bayesian Population Analysis Using WinBUGS (Kery and Schaub, 2011)
- Orchids modeled in states "vegetative", "flowering", "dormant", "dead"
- Observations: "seen vegetative", "seen flowering", "not seen".
- $T$ = 11 annual observation periods 
- $N$ = 236 plants seen before the last observation time



\   

### Orchid Model code

This code is adapted from Bayesian Population Anlaysis (Kery and Schuab):

```{r eval = FALSE}
orchidCode <- nimbleCode({
    ## Survival
    s ~ dunif(0, 1)
    ## Transitions: gamma priors 
    for (i in 1:3){
        a[i] ~ dgamma(1, 1) 
        psiD[i] <- a[i]/sum(a[1:3]) 
        b[i] ~ dgamma(1, 1) 
        psiV[i] <- b[i]/sum(b[1:3]) 
        c[i] ~ dgamma(1, 1) 
        psiF[i] <- c[i]/sum(c[1:3]) 
    }
    ## Define state-transition and observation matrices 	
    for (i in 1:N){
        ps[1,i,1] <- s * psiV[1]
        ps[1,i,2] <- s * psiV[2]
        ps[1,i,3] <- s * psiV[3]
        ps[1,i,4] <- 1-s
        ps[2,i,1] <- s * psiF[1]
        ps[2,i,2] <- s * psiF[2]
        ps[2,i,3] <- s * psiF[3]
        ps[2,i,4] <- 1-s
        ps[3,i,1] <- s * psiD[1]
        ps[3,i,2] <- s * psiD[2]
        ps[3,i,3] <- s * psiD[3]
        ps[3,i,4] <- 1-s
        ps[4,i,1] <- 0 
        ps[4,i,2] <- 0 
        ps[4,i,3] <- 0 
        ps[4,i,4] <- 1
        ##
        ## Define probabilities of O(t) given S(t)
        ##
        po[1,i,1] <- 1 
        po[1,i,2] <- 0 
        po[1,i,3] <- 0 
        po[2,i,1] <- 0 
        po[2,i,2] <- 1 
        po[2,i,3] <- 0 
        po[3,i,1] <- 0 
        po[3,i,2] <- 0 
        po[3,i,3] <- 1 
        po[4,i,1] <- 0 
        po[4,i,2] <- 0 
        po[4,i,3] <- 1 
    }
    ## Likelihood
    for (i in 1:N){
        ## Define latent state at first capture 
        z[i,first[i]] <- y[i,first[i]]
        for (t in (first[i]+1):T){
            ## State process: draw S(t) given S(t-1)
            z[i,t] ~ dcat(ps[z[i,t-1], i, 1:4]) 
            ## Observation process: draw O(t) given S(t) 
            y[i,t] ~ dcat(po[z[i,t], i, 1:3]) 
        }
    }
})
```

\   

To summarize the main model variables:

- `ps[1, i, t, 2]` = probability of transition from state 1 to 2 for individual `i` at time `t`
- `po[1, i, t, 2]` = probability of being observed in state 2 when in state 1 for individual `i` at time `t`
- `s[t]` = survival probability at time `t`
- `psiV[j]` = probability of transition from state 1 (Vegetative) to state `j`
- `psiF[j]` = probability of transition from state 2 (Flowering) to state `j`
- `psiD[j]` = probability of transition from state 3 (Dormant) to state `j`


\  



\   

### Orchid Model data

Data for the orchid model (from Kery and Schuab) <a href="https://danielturek.github.io/nimble-cefe-2019/data/orchid_data.Rdata" target="_blank" style="color: blue">can be downloaded here</a>.

This data file includes:

- `y`: A $N$ = 236 by $T$ = 11 matrix of the observation histories
- `first` A vector of length $T$ = 11, giving the time period of the
  first observation of each orchid

\   

### Latent state model

Let's first fit the latent state version of this model.

We'll use `compareMCMCs` to do it, to help us compare the efficiency
results at the end.

```{r eval = FALSE}
library(nimble)

load('~/Downloads/orchid_data.Rdata')
```

\   

### Define model constants, data, inital values

Define the necesary constants and initial values:

```{r eval = FALSE}
N <- dim(y)[1]
T = dim(y)[2]

orchidConsts <- list(N = N, T = T, first = first)

orchidData <- list(y = y)

orchidInits <- list(a = rep(1, 3),
                    b = rep(1, 3),
                    c = rep(1, 3),
                    s = 0.5,
                    z = y)
```

\   

### Fit the model

Then, fit the orchid model using `compareMCMCs`:

```{r eval = FALSE}
library(compareMCMCs)

out <- compareMCMCs(
    modelInfo = list(code = orchidCode, constants = orchidConsts,
                     data = orchidData, inits = orchidInits),
    MCMCs = 'nimble',
    MCMCcontrol = list(niter = 5000, nburnin = 1000))

## extract the posterior samples
samples <- out$nimble$samples
```


```{r echo = FALSE, eval = FALSE}
save('out', 'samples', file = '~/github/nimble/nimble-cefe-2019/docs/data/orchid_samples.Rdata')
```

```{r echo = FALSE}
load('~/github/nimble/nimble-cefe-2019/docs/data/orchid_samples.Rdata')
```

\  

### Results


```{r fig.height = 3, fig.width = 8}
round(samplesSummary(samples), 2)

library(basicMCMCplots)
basicMCMCplots::samplesPlot(samples)
```





\  

\  

\  

\  

\  

\  

\  

\  

\  

\  

\  

\  

\  

\  



